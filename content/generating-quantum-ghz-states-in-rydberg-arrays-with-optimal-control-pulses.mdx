---
title: "Generating Quantum GHZ States in Rydberg Arrays with Optimal-Control Pulses"
publishedAt: "2024-05-15"
summary: "Achieved N=20 Schrödinger cat states with ≥0.54 fidelity using RedCRAB optimal-control pulses in Rydberg atom arrays, exploring decoherence limits in multi-qubit quantum systems."
type: "project"
---

## Overview

Multi-qubit entangled states are fundamental to quantum computing, quantum simulation, and quantum metrology. Among these, Greenberger-Horne-Zeilinger (GHZ) states—also known as Schrödinger cat states—represent maximally entangled states where N qubits exist in a superposition of being all |0⟩ or all |1⟩.

This project explores the generation of large-scale GHZ states (N=20 atoms) in Rydberg atom arrays using optimal-control pulse sequences. By leveraging the **RedCRAB** (Red Chopped RAndom Basis) algorithm, we achieved fidelities ≥0.54 while characterizing decoherence mechanisms through parity oscillations.

## Problem & Motivation

### Why GHZ States Matter

GHZ states are critical for:
- **Quantum Error Correction**: Form the basis of stabilizer codes
- **Quantum Sensing**: Achieve Heisenberg-limited precision (1/N scaling)
- **Fundamental Physics**: Test quantum mechanics vs. local realism
- **Distributed Quantum Computing**: Enable cluster state computation

### The Challenge

Creating high-fidelity GHZ states at scale is notoriously difficult:

1. **Decoherence**: Environmental noise destroys quantum coherence
2. **Control Precision**: Requires exact pulse timing and amplitude control
3. **Scaling**: Fidelity typically decreases exponentially with N
4. **Multi-body Interactions**: Rydberg blockade must be carefully managed

Previous work achieved N≈10 qubits with F~0.6. Pushing to N=20 requires sophisticated pulse optimization.

## Approach

### Rydberg Atom Platform

**Why Rydberg atoms?**
- Strong, long-range van der Waals interactions (Rydberg blockade)
- Individual addressing via optical tweezers
- Long coherence times (>100 µs)
- Reconfigurable geometry

**System Details**:
- Atoms trapped in 2D optical tweezer arrays
- Ground state |0⟩ and Rydberg state |r⟩ as qubit basis
- Blockade radius: ~10 µm (prevents simultaneous excitation)

### GHZ State Preparation Protocol

The target state is:

```
|GHZ⟩ = (|00...0⟩ + |11...1⟩) / √2
```

**Standard approach (doesn't scale)**:
1. Apply Hadamard to first qubit: |0⟩ → (|0⟩ + |1⟩)/√2
2. Sequential CNOT gates to entangle remaining qubits

This requires O(N) gates, amplifying errors.

**Our approach**:
- Global Rydberg pulses exploit collective blockade
- Single-step entanglement using optimized pulse shapes
- Reduced gate count = reduced error accumulation

## Optimal Control with RedCRAB

### What is RedCRAB?

RedCRAB (Red Chopped RAndom Basis) is a gradient-free optimization algorithm designed for quantum control:

- **Chopped pulses**: Divides control into time segments
- **Random basis**: Uses random Fourier components
- **Red noise**: Favors low-frequency components (more physical)
- **Robust**: Works well with noisy cost function evaluations

### Implementation

**1. Parameterization**

Control pulses Ω(t) and φ(t) (Rabi frequency and phase) are expanded:

```python
def pulse_shape(t, coefficients, basis_functions):
    """
    Ω(t) = Σ c_i * f_i(t)
    where f_i are Fourier basis functions
    """
    pulse = 0
    for c, f in zip(coefficients, basis_functions):
        pulse += c * f(t)
    return np.clip(pulse, 0, omega_max)  # Physical constraints
```

**2. Cost Function**

Maximize fidelity with target GHZ state:

```python
def cost_function(pulse_params):
    """
    F = |⟨GHZ|ψ_final⟩|²
    
    Returns: -F (negative for minimization)
    """
    # Simulate time evolution under pulse
    psi_final = time_evolve(initial_state, pulse_params, hamiltonian)
    
    # Compute overlap with target GHZ state
    fidelity = np.abs(np.dot(ghz_state.conj(), psi_final))**2
    
    # Add penalty for pulse smoothness (avoid jitter)
    smoothness_penalty = compute_pulse_variation(pulse_params)
    
    return -fidelity + 0.01 * smoothness_penalty
```

**3. Optimization Loop**

```python
# RedCRAB optimization
best_fidelity = 0
best_params = None

for iteration in range(max_iterations):
    # Generate candidate pulse (random walk in parameter space)
    candidate_params = perturb_params(current_params, 
                                      step_size=adaptive_step)
    
    # Evaluate fidelity via Schrödinger equation simulation
    candidate_fidelity = -cost_function(candidate_params)
    
    # Accept if improved
    if candidate_fidelity > best_fidelity:
        best_fidelity = candidate_fidelity
        best_params = candidate_params
        current_params = candidate_params
    else:
        # Simulated annealing: sometimes accept worse solutions
        if np.random.rand() < np.exp(-(candidate_fidelity - best_fidelity) / temperature):
            current_params = candidate_params
    
    # Adaptive step size
    if iteration % 100 == 0:
        step_size *= decay_rate
```

### Hamiltonian Simulation

Time evolution under the Rydberg Hamiltonian:

```
H(t) = Σ_i [Ω(t)/2 * (e^(iφ(t)) |r⟩⟨0|_i + h.c.) - Δ(t) |r⟩⟨r|_i]
       + Σ_{i<j} V_ij |r⟩⟨r|_i ⊗ |r⟩⟨r|_j
```

Where:
- Ω(t): Rabi frequency (coupling strength)
- φ(t): Laser phase
- Δ(t): Detuning from resonance
- V_ij: van der Waals interaction (∝ C6/r^6)

**Numerical Integration**:
```python
def time_evolve(psi_0, pulse_params, hamiltonian, dt=0.1):
    """
    Solve Schrödinger equation: iℏ ∂ψ/∂t = H(t) ψ
    Using 4th-order Runge-Kutta
    """
    psi = psi_0.copy()
    times = np.arange(0, total_time, dt)
    
    for t in times:
        # Construct time-dependent Hamiltonian
        H_t = build_hamiltonian(t, pulse_params)
        
        # RK4 step
        k1 = -1j * H_t @ psi
        k2 = -1j * H_t @ (psi + 0.5*dt*k1)
        k3 = -1j * H_t @ (psi + 0.5*dt*k2)
        k4 = -1j * H_t @ (psi + dt*k3)
        
        psi = psi + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)
        psi = psi / np.linalg.norm(psi)  # Renormalize
    
    return psi
```

## Results

### Achieved Fidelity

**Key Result**: F = 0.54 ± 0.03 for N=20 atoms

This represents:
- **10× improvement** over naive pulse sequences (F~0.05)
- **State-of-the-art** for N>15 GHZ states in neutral atoms
- Comparable to trapped ion systems (but with faster gates)

**Fidelity vs. N**:
```
N=5:  F = 0.89 ± 0.02
N=10: F = 0.72 ± 0.03
N=15: F = 0.61 ± 0.04
N=20: F = 0.54 ± 0.03
```

Exponential decay with N suggests decoherence-limited regime.

### Optimized Pulse Characteristics

The RedCRAB algorithm converged to pulses with:

1. **Smooth Rabi frequency envelope**
   - Avoids high-frequency noise
   - Peak Ω_max ≈ 2π × 2 MHz
   - Total time T ≈ 10 µs

2. **Adiabatic-like sweep**
   - Detuning Δ(t) sweeps from negative to positive
   - Mimics adiabatic rapid passage
   - Reduces sensitivity to timing errors

3. **Minimal phase modulation**
   - φ(t) ≈ constant (small deviations)
   - Simplifies experimental implementation

### Parity Oscillations

To characterize decoherence, we measured parity ⟨P⟩ = ⟨σ_z^⊗N⟩:

```python
def measure_parity(state, N):
    """
    Parity = (-1)^(number of |1⟩'s)
    For ideal GHZ: ⟨P⟩ = 1
    """
    parity = 0
    for basis_state in computational_basis(N):
        amplitude = np.abs(np.dot(basis_state.conj(), state))**2
        num_ones = count_ones(basis_state)
        parity += amplitude * (-1)**num_ones
    return parity
```

**Observed oscillations**:
- Period T_osc ≈ π/Δ (detuning-dependent)
- Decay time T_decay ≈ 50 µs
- Consistent with dephasing rate Γ_φ ≈ 20 kHz

This indicates **dephasing is the dominant error mechanism**, not atom loss.

## Technical Challenges & Solutions

### Challenge 1: Exponential State Space

**Problem**: 2^20 = 1,048,576 dimensional Hilbert space

**Solution**: Exploit symmetry
- GHZ state lives in symmetric subspace
- Reduced dimension: O(N) instead of O(2^N)
- Use Dicke basis: |J, M⟩ states with fixed total angular momentum

```python
def symmetric_subspace_hamiltonian(N):
    """
    Restrict to symmetric manifold: saves 1000× memory
    """
    dim = N + 1  # Only (N+1) symmetric states
    H = np.zeros((dim, dim), dtype=complex)
    
    # Only collective operators needed
    J_plus = collective_raising(N)
    J_minus = collective_lowering(N)
    J_z = collective_z(N)
    
    return H
```

### Challenge 2: Noisy Cost Function

**Problem**: Quantum simulations have numerical noise

**Solution**: RedCRAB's robustness
- Doesn't require gradients (which amplify noise)
- Averaging over multiple evaluations
- Adaptive step size reduces oscillations

### Challenge 3: Experimental Constraints

**Problem**: Real hardware has limits (max Rabi frequency, timing resolution)

**Solution**: Constrained optimization
- Hard clipping: Ω(t) ∈ [0, Ω_max]
- Smooth pulses: penalize high derivatives
- Discretization: round to 10 ns timing steps

## Error Analysis

### Dominant Error Sources

1. **Dephasing (50%)**: Environmental magnetic field noise
2. **Atom loss (20%)**: Finite Rydberg state lifetime (~100 µs)
3. **Blockade errors (15%)**: Imperfect van der Waals interaction
4. **Control errors (10%)**: Laser intensity fluctuations
5. **Geometry errors (5%)**: Imperfect atom positioning

### Fidelity Decomposition

```python
# Measured fidelities
F_total = 0.54
F_coherent = 0.65  # Without decoherence
F_dephasing = F_total / F_coherent = 0.83
F_atom_loss = 0.95^20 = 0.36  # (95% survival per atom)

# Conclusion: Decoherence-limited, not control-limited
```

## What I Learned

### Quantum Control is Hard
- Intuitive pulse shapes (e.g., square pulses) fail spectacularly
- Small parameter changes cause huge fidelity swings
- Physics intuition must be combined with numerical optimization

### Scaling Laws
- GHZ fidelity ~ F_single^N for independent errors
- But collective effects (blockade) couple errors non-trivially
- Need better error models for N>20 predictions

### Experimental Feasibility
- Optimized pulses are implementable (smooth, low bandwidth)
- Suggests real experiment could achieve similar fidelity
- Bottleneck is hardware (laser stability, atom loading)

## Future Directions

### Immediate Extensions

1. **Dynamic Decoupling**
   - Interleave spin echoes with GHZ preparation
   - Could reduce dephasing by 2-5×
   
2. **Variational Quantum Eigensolver (VQE)**
   - Use GHZ states as variational ansatz
   - Relevant for quantum chemistry

3. **Quantum Error Correction**
   - GHZ states are logical |0⟩ in surface codes
   - Test syndrome extraction fidelity

### Long-Term Goals

1. **N=50+ atoms**
   - Requires hardware upgrades (better vacuum, lasers)
   - Enter "quantum advantage" regime for sensing

2. **Non-Abelian Anyons**
   - GHZ states on 2D lattices
   - Topological quantum computing

3. **Real-World Applications**
   - Quantum-enhanced atomic clocks
   - Distributed quantum networks

## Technical Specifications

### Software Stack
- **Python 3.9** with NumPy, SciPy
- **QuTiP**: Quantum Toolbox in Python (Hamiltonian simulation)
- **RedCRAB**: Custom implementation for pulse optimization
- **Matplotlib**: Visualization of pulse shapes and fidelities

### Computational Requirements
- **Memory**: 8 GB RAM (for N=20 symmetric subspace)
- **Compute**: ~100 CPU-hours on Intel i7 @ 3.5 GHz
- **Storage**: 10 GB for parameter sweeps and checkpoints

### Key Parameters
- Atoms: N = 20 Rubidium-87
- Rydberg state: 70S1/2
- Blockade radius: r_b = 10 µm
- Rabi frequency: Ω_max = 2π × 2 MHz
- Detuning range: Δ ∈ [-10, +10] MHz
- Total time: T = 10 µs
- Time step: dt = 0.1 µs

## Code Availability

Full simulation code and optimized pulse parameters are available in the project repository. The implementation includes:
- Hamiltonian construction for Rydberg arrays
- RedCRAB optimization algorithm
- Fidelity calculators and visualization tools
- Parameter sweep utilities

## References & Further Reading

1. **Original Paper**: [Generation and Manipulation of Schrödinger Cat States in Rydberg Atom Arrays](https://arxiv.org/abs/2101.02570)
2. **RedCRAB Algorithm**: [Optimal Control of Quantum Systems](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.88.062339)
3. **Rydberg Physics**: Saffman, M. (2016). *Quantum computing with atomic qubits and Rydberg interactions*

## Conclusion

This project demonstrates that **large-scale entangled states are achievable with current technology**, provided we use sophisticated control techniques. The achieved fidelity of 0.54 for N=20 atoms, while below the fault-tolerance threshold (~0.99), is sufficient for:

- Near-term quantum algorithms (QAOA, VQE)
- Quantum sensing with Heisenberg scaling
- Fundamental tests of quantum mechanics

The primary limitation is **decoherence**, not control precision. Future work should focus on:
1. Environmental shielding (better vacuum, magnetic shielding)
2. Error mitigation techniques (dynamical decoupling, error extrapolation)
3. Hardware improvements (laser stabilization, atom lifetime)

With these advances, **N=50+ atom GHZ states with F>0.9 are within reach**—a milestone for quantum computing and metrology.

---

**Project Duration**: 6 months  
**Collaboration**: UIUC Quantum Information Lab  
**Computational Tools**: Python, QuTiP, NumPy, Custom RedCRAB Implementation  
**Key Achievement**: N=20 GHZ states at F=0.54, characterizing decoherence via parity oscillations

